# -*- coding: utf-8 -*-
"""Pratica3.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1iZjpitO_hsAlxAhV6qmz5ozEUJNh8LcM
"""

!pip install pefile

from google.colab import files
uploaded =files.upload()

#1) Escreva um script em Python (ou .ipynb) que receba como entrada um arquivo ou 
#diretório e enumere a seções executáveis do(s) binário(s), imprimindo na saída padrão
#um dicionário de listas, onde a chave é o nome do binário e o valor é uma lista de seções executáveis.


import pefile

#! localizacao do arquivo
file_location = 'ftp.exe'
# abre arquivo
pe = pefile.PE(file_location)
dict = {}
listasecoes = []

chave = 'nome do Arquivo Binario'                                               #preciso colocar o nome do arquivo que entrou aqui e não sei como
for section in pe.sections:
   if section.IMAGE_SCN_CNT_CODE == True or section.IMAGE_SCN_MEM_EXECUTE ==  False: ###Mudar para true... Só está assim para ter mais de uma seção executavel e testar
      #rotulo = 'nome do Arquivo Binario'
      listasecoes.append (section.Name.decode('utf-8'))                                

dict[chave] = listasecoes
print(dict)

#2)Escreva outro script em Python (ou .ipynb) que receba como entrada dois arquivos .exe e os compare,
#imprimindo na saída padrão quais seções são comuns a ambos os binários, quais somente estão presentes 
#no binário 1 e quais somente estão presentes no binário 2. 



import pefile
#! localizacao do arquivo
file_location = 'mediainfo.exe'
# abre binário1
binario1 = pefile.PE(file_location)

file_location = 'notepad.exe'
# abre binário2
binario2 = pefile.PE(file_location)

#cria listas para armazenar as seções
secoes1 = []
secoes2 = []

#acrescenta na lista as seções do binário 1
for section in binario1.sections:
  secoes1.append(section.Name.decode('utf-8'))

#acrescenta na lista as seções do binário 2
for section in binario2.sections:
  secoes2.append(section.Name.decode('utf-8'))


#verifica seções comuns aos 2 binários  
comum = [x for x in secoes2 if x in secoes1]

#verifica seções apenas do binário 1
so_secao1 = list(set(secoes1) - set(secoes2))

#verifica seções apenas do binário 2
so_secao2 = list(set(secoes2) - set(secoes1))

#imprime resultados
print("Seções comuns nos dois binarios %s" % comum)
print("Seções apenas do binario 1 %s" % so_secao1)
print("Seções apenas do binario 2 %s" % so_secao2)

#Código de https://gist.github.com/rjzak/47c28bf3421241c03653f1619e0d8d92

import pefile
import sys

'''
   Test the section characteristics to see if the section is executable. Check for flags:
       * 0x00000020 = Section contains code
       * 0x20000000 = Section is executable
   
   Not all executable sections are conveniently named .text. And pefile doesn't expose this information directly.
   Source: https://msdn.microsoft.com/en-us/library/ms809762.aspx?f=255&MSPPError=-2147217396
   '''
def isSectionExecutable(section):
    characteristics = getattr(section, 'Characteristics')
    if characteristics & 0x00000020 > 0 or characteristics & 0x20000000 > 0:
        return True
    return False

def checkSections(pe):
    for section in pe.sections:
        if isSectionExecutable(section):
            print ("%s IS EXECUTABLE!" % section.Name)
        else:
            print ("%s is not executable" % section.Name)

if __name__ == '__main__':
    if len('ftp.exe') == 1:
        print ("Provide an EXE file!")
        sys.exit(1)
    
    for arg in sys.argv[1:]:
        pe = pefile.PE('ftp.exe')
        print ("\n%s..." % arg)
        checkSections(pe)

#for section in pe.sections:
 #   if section.IMAGE_SCN_CNT_CODE == True or section.IMAGE_SCN_MEM_EXECUTE ==  False:  ###Mudar para true... Só está assim para ter mais de uma seção executavel e testar
  #    secoes = section.Name.decode('utf-8')
   #   print("\tA seção " + section.Name.decode('utf-8') + "\té executavel.")
#